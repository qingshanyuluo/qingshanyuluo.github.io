{"meta":{"title":"Lennon Blog","subtitle":"小帕博客","description":null,"author":"lennon","url":"http://papa.lennon.xyz","root":"/"},"pages":[{"title":"","date":"2020-05-15T10:10:49.970Z","updated":"2020-05-15T10:10:49.970Z","comments":false,"path":"categories/index.html","permalink":"http://papa.lennon.xyz/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-05-15T10:10:49.970Z","updated":"2020-05-15T10:10:49.970Z","comments":true,"path":"about/index.html","permalink":"http://papa.lennon.xyz/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-05-15T10:10:49.970Z","updated":"2020-05-15T10:10:49.970Z","comments":false,"path":"tags/index.html","permalink":"http://papa.lennon.xyz/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"git分支和多人协同开发","slug":"resource/工具/git分支和多人协同开发","date":"2020-01-18T02:43:39.000Z","updated":"2020-05-15T10:10:49.970Z","comments":true,"path":"/posts/413141/","link":"","permalink":"http://papa.lennon.xyz/posts/413141/","excerpt":"","text":"分支的理解 只有一条时间线 新建分支只是增加一个指向时间线的指针 继续更新时间线 合并 让master的指针指向dev就行了，这时候如果要删除dev分支就只需要删除这个dev指针就行了： 5. 解决冲突 当多个分支同时，就会变成这样： 这种情况，git无法像刚刚一样，直接将master指针移向feature1那样，如果直接输入合并命令，就会合并失败 合并失败后git会将工作区冲突的文件变成这样： 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADddd=======dev&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev 修改过后再add commit一次 就会合并成功 就像这样： 6. bug分支 feature分支多人协作多人协作是git的重要特性 冲突解决如果 origin被其他人push过后，自己再想push就会有冲突，必须先pull pull后文件也会像这样： 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD System.out.println(\"dev\"); System.out.println(\"fdsf\");=======&gt;&gt;&gt;&gt;&gt;&gt;&gt; d46723cb2f115382b802f7c02f9020beea4714cb 必须解决冲突后提交后再push 打标签标签就是对那串哈希出来的码取的特殊名字 给当前版本，当前分支打标签：git tag v1.0 查看所有标签：git tag 给指定的commit id 打标签：git tag v0.9 f52c633 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m \"version 0.1 released\" 1094adb 用命令git show可以看到说明文字： 123456789101112131415$ git show v0.1tag v0.1Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 22:48:43 2018 +0800version 0.1 releasedcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLdiff --git a/readme.txt b/readme.txt... GitHub使用唯一远程仓库进行多台电脑的远程开发方式就用以上方式，不过对于GitHub而言，这样必授权其他电脑拥有改写自己整个账号代码的权利，配合GitHub，如果我们想改其他人的代码，可以先fork下来，这样就变成你账号下的项目了，自己随心所欲修改后可以提交pull request，别人如果心情好，可能就采纳l 参考：廖雪峰git教程 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"工具","slug":"工具","permalink":"http://papa.lennon.xyz/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"git","slug":"git","permalink":"http://papa.lennon.xyz/tags/git/"}]},{"title":"vuecli复习elementui 初使用","slug":"resource/js/vuecli复习elementui 初使用","date":"2019-12-21T02:43:23.000Z","updated":"2020-05-15T10:10:49.970Z","comments":true,"path":"/posts/hkhlc06699c0/","link":"","permalink":"http://papa.lennon.xyz/posts/hkhlc06699c0/","excerpt":"","text":"实训作业，数据库的管理系统，应付老师使用mybtais+springboot+vue+element ui 搭建了一个小区的物业管理系统，复习了一下这些技术栈，不过js确实把我迷的啊~~ 后端就是简单的curd 前端是单页面应用，没有保持登录的功能，主要是token技术还没熟练，所以这次主要是ui上的工作 之前学vue的时候功力尚浅，只知然不知其所以然，这次有了新的理解， 项目目录：.├── README.md├── babel.config.js├── node_modules/├── package-lock.json├── package.json├── public/├── src/└── vue.config.js 笔者没有细致的学过node npm 对于其中的理解不求精准专业，但求易懂，望网友包容 总的理解：node的出现使得js跳出浏览器的范围，js可以变身类似与python这样的语言操作文件，监听网络等等，vuecli就是类似于这样的一个“软件”，npm 安装包的方式很是粗暴 全局的存在用户目录下，项目的直接存在项目下（所以gitignore一定要把node_modules排除） vue.config.js一个js文件，是自己新加的，vuecli应该认识，可以读取里面的设置 src/代码 public/favicon和一个基础的html内容提示：We’re sorry but wuliu doesn’t work properly without JavaScript enabled. Please enable it to continue还有个id=app的div package.js&amp;package-lock.jsonpackage.json 这个文件是 npm init 时创建的一个文件，会记录当前整个项目中的一些基础信息。而 package-lock.json 这个文件却是 node_modules 文件夹或者 package.json 文件发生变化时自动生成的。这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。 node_modules安装项目域的node模块 babelbabel官网正中间一行黄色大字写着“babel is a javascript compiler”，翻译一下就是babel是一个javascript转译器。为什么会有babel存在呢？原因是javascript在不断的发展，但是浏览器的发展速度跟不上。以es6为例，es6中为javascript增加了箭头函数、块级作用域等新的语法和Symbol、Promise等新的数据类型，但是这些语法和数据类型并不能够马上被现在的浏览器全部支持，为了能在现有的浏览器上使用js新的语法和新的数据类型，就需要使用一个转译器，将javascript中新增的特性转为现代浏览器能理解的形式。babel就是做这个方面的转化工作。 src1234567891011121314151617181920212223242526.├── App.vue├── assets│ └── logo.png├── components│ ├── Complaint.vue│ ├── Express.vue│ ├── NeedPay.vue│ ├── NeedRepair.vue│ ├── NewRepair.vue│ ├── Paid.vue│ ├── ShowInfo.vue│ ├── ShowProperty.vue│ ├── ShowUser.vue│ ├── UploadInfo.vue│ ├── UploadProperty.vue│ └── admin├── main.js├── router│ └── index.js└── views ├── Admin.vue ├── Login.vue ├── Main.vue ├── Register.vue └── ULogin.vue 任何.vue文件分三个部分： 12345678910111213&lt;template&gt; &lt;/template&gt;&lt;script&gt;export default {}&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 这里主要是script部分 export是 node部分的语法参考将模块暴露出去 查看Admin.vue是如何引用其他模块的: 1&lt;Express/&gt; 12345678import Express from '../components/admin/Express'export default { name: 'Admin', components: { Express }} Vue的学习可以查看官方文档说几个要点： mvvmMVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象，是业务逻辑层（一切js可视业务逻辑，比如表单按钮提交，自定义事件的注册和处理逻辑都在viewmodel里面负责监控俩边的数据）在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。这种自动同步是因为ViewModel中的属性实现了Observer，当属性变更时都能触发对应的操作。ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 组件化 组件化是开始就吸引我的，保证代码的重用性，使得前端开发现代化。 element uiui框架使得我的开发变得很容易，现在基本上回不去了，是单体开发的重要快捷方法，文档易懂 axio12345678910111213var _this = thislet param = new URLSearchParams()param.append('name', this.form.username)param.append('pwd', this.form.password)this.$axios.post('login', param) .then(function (response) { console.info(response.data) if (response.data.type === 0) { _this.$router.push({ name: 'Main', params: { user: response.data } }) } else { _this.$alert('请使用管理员平台登录', '提示', {}) } }) this的指向的，js的大坑，除了上面的方法，还可使用箭头函数，不过js的报错还是不够友好难找到错误，学好js多用多看chrome的控制台， http postparams 是参数，是请求头的部分，springmvc用@RequestParam 接收其他的js对象在提交的时候则是放在body部分以json形式传输在springmvc中可以用@RequestBody接收 使用postman生成代码如下 1234567891011POST /express/get/4 HTTP/1.1Host: localhost:8081Content-Type: application/x-www-form-urlencodedusername: abcCache-Control: no-cachePostman-Token: 227f3304-2477-4cb6-ae6f-dee9931d11f1{ \"owner_id\": 4, \"create_time\": \"2019-12-17T16:00:00.000Z\"} 空行后是body部分而param在前面 项目代码 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"js","slug":"js","permalink":"http://papa.lennon.xyz/categories/js/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://papa.lennon.xyz/tags/vue/"},{"name":"npm","slug":"npm","permalink":"http://papa.lennon.xyz/tags/npm/"},{"name":"node","slug":"node","permalink":"http://papa.lennon.xyz/tags/node/"},{"name":"element ui","slug":"element-ui","permalink":"http://papa.lennon.xyz/tags/element-ui/"}]},{"title":"加密技术浅认识","slug":"resource/java/加密技术","date":"2019-12-07T02:43:39.000Z","updated":"2020-05-15T10:10:49.970Z","comments":true,"path":"/posts/4324432334/","link":"","permalink":"http://papa.lennon.xyz/posts/4324432334/","excerpt":"","text":"简单hash加密哈希算法又称摘要算法，是一个多对一的映射，很多典型的例子如MD5，SHA-1 数据库中不能直接存密码的明文，否则一旦数据库被攻破，就可以登陆所有用户的账号，方法是存储用户口令的哈希，例如，MD5。在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。 加盐哈希存储简单的哈希加密并不能有效抵御上一种情况，虽然穷举很低效，但是如果做到一张对应表，那就可以直接算出来明文，为此，可以对明文密码加上一串随机数据，再进行hash算法，这样用表的方式也推不到原始的明文，然鹅，要验证输出的哈希，必须同时提供“认证码”。但是使用随机生成的盐也是有一定的弊端，较大的弊端就是，这个盐也必须存储，所以也是有机会获取的盐需要每个用户唯一，这样可以很大程度上防止查表，因为盐不同，即使知道盐是什么也无法生成数量如此庞大的表。可以使用128位的uuid来作为用户的盐，这样可以保证唯一性也可以保证盐的长度。但是我个人更建议盐可以使用某种非公开的算法根据用户信息生成，而不是直接存储在数据表中的信息，即盐也需要保密。事实上盐最好也不公开，最简单的办法就是分为两部分，一部分为入参数据使用用户信息，这些存储于数据库，另外一部分使用生成算法，这些固化在代码中，不会随数据库沦陷而泄露。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java","slug":"java","permalink":"http://papa.lennon.xyz/categories/java/"}],"tags":[{"name":"加密","slug":"加密","permalink":"http://papa.lennon.xyz/tags/%E5%8A%A0%E5%AF%86/"},{"name":"hash","slug":"hash","permalink":"http://papa.lennon.xyz/tags/hash/"}]},{"title":"几种开发工具的认识","slug":"resource/工具/几种开发方式的认识","date":"2019-12-07T02:43:39.000Z","updated":"2020-05-15T10:10:49.970Z","comments":true,"path":"/posts/432434243/","link":"","permalink":"http://papa.lennon.xyz/posts/432434243/","excerpt":"","text":"纯Windows纯window下开发，有很多困难，普通的环境Windows配起来都很是费劲 Windows jvm python + 远程/虚拟机/wsl 组件开始编程的时候大部分都是用这种方式，但由于windows火热的编程时代一去不复返，浏览器和移动端开始占据市场主流，在这个时代，linux的地位空前的高，大多数的后端服务器都运行在Linux平台，与此同时，开源的力量也变得空前的强大，考虑到大多数开源组件都是在Linux下先发布，同时对类unix系统的支持也比较好，例如mysql redis这些在linux比较好的组件就放在linux下运行，然后通过网络和本地windows的程序连接，达到开发的目的。 ssh+vscode远程开发早就听说过命令行大佬写代码从不用图形界面，直接ssh连过去就写。然鹅vim等编辑器不经过费劲的折腾实在是比不上现代ide方便，同时学习成本也很高，感谢微软黑科技，vscode的remote development 现阶段已经完善到一定程度，通过ssh连接linux服务器，就可以获得一个类似与linux下打开的vscode，同时随着vscode插件的完善，现在直接用vscode已经可以很快乐的写c/c++ python nodejs，java也已经可以相当愉快的写了。 容器以docker为代表的容器技术极大的方便了微服务下环境的搭建，只要是linux下一套环境，容器就可以将之打包，然后在任何装有docker下的机器上运行，类似于搬上去一整个虚拟机的运行环境。然鹅又没有虚拟机那么重量化，其实docker只是为你的运行组件隔离出来了一个环境，其底层还是用本身操作系统，这也就是为啥docker不能虚拟出一个windows环境一样，应为虚拟出来的环境本质还是用同一套内核的。 虚拟机买不起云服务器的同学可以使用虚拟机替代，出了占用本机资源这一个缺点，虚拟机相比于自己花那一点小钱买的云服务器拥有更高的性能，同时和本机的连接不会受外部网路影响，同时你将会学到很多网络的知识 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"工具","slug":"工具","permalink":"http://papa.lennon.xyz/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://papa.lennon.xyz/tags/vscode/"},{"name":"docker","slug":"docker","permalink":"http://papa.lennon.xyz/tags/docker/"}]},{"title":"springCloud入门","slug":"resource/java/springcloud入门","date":"2019-12-01T02:43:39.000Z","updated":"2020-05-15T10:10:49.970Z","comments":true,"path":"/posts/13124536/","link":"","permalink":"http://papa.lennon.xyz/posts/13124536/","excerpt":"","text":"Spring Cloud为开发人员提供了工具来快速构建分布式系统中一些常见的模式(例如配置管理、服务发现、断路器、智能路由、micro-proxy、 control bus控制总线、one-time tokens 、global locks 全局锁、 leadership election ,分布式会话、集群状态)。组织分布式系统使之模板化(Coordination of distributed systems leads to boiler plate patterns )，使用Spring Cloud开发者可以快速建立实现这些模式的服务和应用程序。他们将适用于任何分布式环境中,包括开发人员自己的笔记本电脑,物理机( bare metal data centers)数据中心,云计算等和管理平台。 FeaturesSpring Cloud focuses on providing good out of box experience for typical use cases and extensibility mechanism to cover others. Distributed/versioned configuration 【分布式以及版本化的配置】 Service registration and discovery【服务注册与发现】 Routing【路由】 Service-to-service calls【服务调用】 Load balancing【负载均衡】 Circuit Breakers【断路器】 Global locks Leadership election and cluster state Distributed messaging【分布式消息】 服务注册与发现统一化的管理，可以实现各个微服务间良好的解耦，服务提供者和消费者都注册到Eureka服务器上，浏览器访问消费者地址，消费者会通过Eureka服务器上服务提供者的名字，找到提供者的真实路径，进行调用。高可用时可以搭建几个Eureka服务器，互相注册，复制各自信息。 贴一下关键代码： eureka server：项目开始前更改host 将 discovery 映射到127.0.0.1 m1\\src\\main\\java\\xyz\\lennon\\EurekaApplication.java 12345678910111213package xyz.lennon;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class, args); }} application.yml 1234567891011server: port: 8761 # 指定该Eureka实例的端口eureka: instance: hostname: discovery # 指定该Eureka实例的主机名 client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 用户模块m2\\src\\main\\java\\xyz\\lennon\\UserApplication.java 12345678910111213package xyz.lennon;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class UserApplication { public static void main(String[] args) { SpringApplication.run(UserApplication.class, args); }} application.yml 123456789101112131415161718192021222324252627server: port: 8001spring: application: name: microservice-provider-user # 项目名称尽量用小写 jpa: generate-ddl: false show-sql: true hibernate: ddl-auto: none datasource: # 指定数据源 platform: h2 # 指定数据源类型 schema: classpath:schema.sql # 指定h2数据库的建表脚本 data: classpath:data.sql # 指定h2数据库的insert脚本logging: level: root: INFO org.hibernate: INFO org.hibernate.type.descriptor.sql.BasicBinder: TRACE org.hibernate.type.descriptor.sql.BasicExtractor: TRACE com.itmuch.youran.persistence: ERROReureka: client: serviceUrl: defaultZone: http://discovery:8761/eureka/ # 指定注册中心的地址 instance: preferIpAddress: true 启动上述两个模块，打开 http://discovery:8761/ 就可以看到监控页面注册的用户模块，用户模块也可以同时启动在不同端口上，注册到eureka，值得注意的是，应用名字如果相同，注册中心就会认为是同一个服务的不同实例。 负载均衡借助Ribbon实现负载均衡， 规则用默认的。 开启eureka server 和用户模块，为了模拟负载均衡，在不同的端口启动多个用户模块 调用用户模块的模块m3\\src\\main\\java\\xyz\\lennon\\MovieRibbonApplication.java 1234567891011121314151617181920212223242526package xyz.lennon;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@SpringBootApplication@EnableDiscoveryClientpublic class MovieRibbonApplication { /** * 实例化RestTemplate，通过@LoadBalanced注解开启均衡负载能力. * @return restTemplate */ @Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); } public static void main(String[] args) { SpringApplication.run(MovieRibbonApplication.class, args); }} m3\\src\\main\\java\\xyz\\lennon\\RibbonService.java 123456789101112131415161718package xyz.lennon;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;/** * dfd */@Servicepublic class RibbonService { @Autowired private RestTemplate restTemplate; public User findById(Long id) { return this.restTemplate.getForObject(\"http://microservice-provider-user/\" + id, User.class); }} 可以看到restTemplate是基于注册的应用名调用的 1234567891011server: port: 8010spring: application: name: microservice-consumer-movie-ribboneureka: client: serviceUrl: defaultZone: http://discovery:8761/eureka/ instance: preferIpAddress: true 多次请求 http://localhost:8010/ribbon/1 观察后台日志发现负载均衡起作用了 熔断器Hystrix 防止在服务之间调用失败时“卡死”的情况，停止无意义的调用并给出监控信息 对比上文模块的改进： 调用用户模块的模块m4\\src\\main\\java\\xyz\\lennon\\MovieRibbonHystrixApplication.java 123456789101112131415161718192021222324252627282930313233package xyz.lennon;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;/** * 使用@EnableCircuitBreaker注解开启断路器功能 * * @author eacdy */@SpringBootApplication@EnableDiscoveryClient@EnableCircuitBreakerpublic class MovieRibbonHystrixApplication { /** * 实例化RestTemplate，通过@LoadBalanced注解开启均衡负载能力. * @return restTemplate */ @Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); } public static void main(String[] args) { SpringApplication.run(MovieRibbonHystrixApplication.class, args); }} m3\\src\\main\\java\\xyz\\lennon\\RibbonHystrixService.java 12345678910111213141516171819202122232425262728293031323334353637383940package xyz.lennon;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;@Servicepublic class RibbonHystrixService { @Autowired private RestTemplate restTemplate; private static final Logger LOGGER = LoggerFactory.getLogger(RibbonHystrixService.class); /** * 使用@HystrixCommand注解指定当该方法发生异常时调用的方法 * @param id id * @return 通过id查询到的用户 */ @HystrixCommand(fallbackMethod = \"fallback\") public User findById(Long id) { return this.restTemplate.getForObject(\"http://microservice-provider-user/\" + id, User.class); } /** * hystrix fallback方法 * @param id id * @return 默认的用户 */ public User fallback(Long id) { RibbonHystrixService.LOGGER.info(\"异常发生，进入fallback方法，接收的参数：id = {}\", id); User user = new User(); user.setId(-1L); user.setUsername(\"default username\"); user.setAge(0); return user; }} 可以看到restTemplate是基于注册的应用名调用的 1234567891011server: port: 8011spring: application: name: microservice-consumer-movie-ribbon-with-hystrixeureka: client: serviceUrl: defaultZone: http://discovery:8761/eureka/ instance: hostname: ribbon # 此处，preferIpAddress不设置或者设为false，不能设为true，否则影响turbine的测试。turbine存在的问题：eureka.instance.hostname一致时只能检测到一个节点，会造成turbine数据不完整 关闭用户模块，并没有无响应，而是 获得结果：{\"id\":-1,\"username\":\"default username\",\"age\":0}，另外日志打印：c.i.c.s.u.service.RibbonHystrixService : 异常发生，进入fallback方法，接收的参数：id = 1 。 参考教程： 使用Spring Cloud与Docker实战微服务 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java","slug":"java","permalink":"http://papa.lennon.xyz/categories/java/"}],"tags":[{"name":"springCloud","slug":"springCloud","permalink":"http://papa.lennon.xyz/tags/springCloud/"},{"name":"java","slug":"java","permalink":"http://papa.lennon.xyz/tags/java/"},{"name":"分布式","slug":"分布式","permalink":"http://papa.lennon.xyz/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"浅谈spring","slug":"resource/java/浅谈spring","date":"2019-11-28T02:43:39.000Z","updated":"2020-05-15T10:10:49.970Z","comments":true,"path":"/posts/16104523/","link":"","permalink":"http://papa.lennon.xyz/posts/16104523/","excerpt":"","text":"老生长谈 IOC学习spring 首先要祭上spring 官方那张图 spring framework runtime spring framework runtime 可以看出最核心的那个 是一个容器，IOC是spring最基本的能力，简单来说inversion of control，就是把软件的部分控制由程序员交给了spring ，最典型的就是对象的新建和初始化（依赖建立）的反转，除了解耦和减少程序员代码，spring的IOC还为其他的功能打下了基础。 粗略的组件理解 core 提供了IOC过程中需要的“工具”，所有操作都需要它 context 上下文，在计算机系统中，进程执行时有进程上下文，如果进程在执行的过程中遇到了中断，CPU 会从用户态切换为内核态（当然这个过程用户进程是感知不到的，由硬件来实现的），此时进程处于的进程上下文会被切换到中断上下文中，从而可以根据中断号去执行相应的中断程序。 内容出处 DefaultListableBeanFactory这就是大家常说的 ioc 容器，它里面有很多 map、list。spring 帮我们创建的 singleton 类型的 bean 就存放在其中一个 map 中。我们定义的监听器（ApplicationListener）也被放到一个 Set 集合中 BeanDefinitionRegistry把一个 BeanDefinition 放到 beanDefinitionMap。 AnnotatedBeanDefinitionReader针对 AnnotationConfigApplicationContext 而言。一个 BeanDefinition 读取器。 扩展点集合存放 spring 扩展点（主要是 BeanFactoryPostProcessor、BeanPostProcessor）接口的 list 集合。 Beans 存入到spring容器中的对象 AOP AOP 核心概念和IOC一样非常好理解，就是抽取各部分中不重要或者重复的部分，拿出来（从侧面切出来）将原本程序从上到下执行逻辑中不重要的分离到侧面（常见的记录日志，权限控制） AspectJ 是另一种 aop框架（貌似比spring AOP更强大？）原本的aop的编程方式太反人类了，所以spring后来借用了aspectj的方式，但核心还是spring spring借用cglib而不是jdk自己的动态代理主要是应为要完成基于类的代理而不是为了啥效率 （1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类（2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法因为是继承，所以该类或方法最好不要声明成final document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java","slug":"java","permalink":"http://papa.lennon.xyz/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://papa.lennon.xyz/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://papa.lennon.xyz/tags/spring/"}]},{"title":"几门语言浅显的认知","slug":"resource/wego/几门语言的理解","date":"2019-11-28T02:43:39.000Z","updated":"2020-05-15T10:10:49.970Z","comments":true,"path":"/posts/16128731/","link":"","permalink":"http://papa.lennon.xyz/posts/16128731/","excerpt":"","text":"前言计算机发展这么多年，流行的语言在其各自擅长的领域都是不可替代的存在；同时在前几门语言中，我们也没有看到两个定位相似的语言。排名前几的语言没有高下之分。 java常年排名第一，岗位也是最多的，虽然理论上适合干几乎所有领域，但现在其实也就在服务器端称王了，其他领域还是弟弟，其严格的类型约束，良好的面向对象支持，GC机制和不错的运行速度很适合大型超大型的项目开发，再加上在服务器领域深耕多年，生态完整，所以很适合干后端。（其实gui开发也是他擅长的，另一门和java很相似的语言c#就很适合开发windows桌面应用，安卓也是java开发，java自带的gui框架swingjavaFX在上个时代还是很流行的，谷歌新的gui框架flutter用的也是一门和java类似的语言dart，但总结，java的gui要么被类似的替代了，要么过时了） python两个特点 简单 语法简单，给python设计的各种api也简单（这是我的感觉） 库多，啥领域的都有，图形界面开发，后端，科学计算，人工智能，爬虫等等(PS：python应该是主力语言中最慢的的了哈哈哈，一方面解释型语言本来就慢，另一方面，另一个主流的解释型语言js有谷歌大大开发的V8引擎，贼快哈哈哈，不够python更多时候是扮演一个指挥者的角色，慢不慢不重要) cc太过底层，不支持面向对象，主要就是在嵌入式那边开发底层驱动，或者写个操作系统内核（linux内核就是c写的，据说如果用c++重写可以减少四分之三的代码量，但是Linus就是不这样，怕c++有坑） c++c++不只是c的面向对象版本，事实上他太大而全了，啥都能写，而且任何一个程序员都可以按照自己的喜好把c++写的像另一门语言（在我接触的Qt给我的感觉就是设计的很像java），但这是一门为“聪明人”设计的语言，而大多数人“不聪明”。所以我认为这在很多情况下不是门”好语言”，以前的c++可谓个方面通吃，现在 js就是网页了，B/S架构越来越流行，而浏览器里除了js几乎不可能出现第二种语言，并且这几年js有向外的发展趋势（app，后端），（js语法有很多坑，这几年的es5 6 7和typescript就在填坑） 大学阶段毫无疑问这几门应该都要会，c/c++主要作用在于完成老师作业和刷算法题python在爬数据，写一些小脚本方面很有用（主要是库多）java 和 js 作为互联网中几乎占据统治地位的语言工作岗位最多 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"wego","slug":"wego","permalink":"http://papa.lennon.xyz/categories/wego/"}],"tags":[{"name":"语言","slug":"语言","permalink":"http://papa.lennon.xyz/tags/%E8%AF%AD%E8%A8%80/"}]},{"title":"软件安装","slug":"resource/wego/软件安装","date":"2019-11-28T02:43:39.000Z","updated":"2020-05-15T10:10:49.970Z","comments":true,"path":"/posts/1612321/","link":"","permalink":"http://papa.lennon.xyz/posts/1612321/","excerpt":"","text":"Windows端编辑器 vscode（主角，不多说） typora（让你写markdown更简单，和这节课关系不大，推荐安装，可选） 语言(可选)看官方教程的，第一步下载完就算完成任务了 python（以后想学的，参照微软教程） java（微软提供了一键安装包） node（可选，官方教程(有坑，，不推荐)） wsl安装指南（可选）参考教程如果不知道选什么发行版 选Ubuntu document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"wego","slug":"wego","permalink":"http://papa.lennon.xyz/categories/wego/"}],"tags":[{"name":"软件安装","slug":"软件安装","permalink":"http://papa.lennon.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}]},{"title":"动态代理与AOP","slug":"resource/java/动态代理","date":"2019-11-24T12:48:02.000Z","updated":"2020-05-15T10:10:49.970Z","comments":true,"path":"/posts/16113431/","link":"","permalink":"http://papa.lennon.xyz/posts/16113431/","excerpt":"","text":"前提代理设计模式：面向对象中常见的设计模式，核心思想就是将核心功能转交给代理者完成，完成核心功能和非核心功能的解耦。 动态代理和静态代理：静态代理，怎么代理的代码写死，要实现一个新的代理功能就要新写一个一段完整的代码；动态代理：运用反射动态地在内存或者磁盘中创建类并运行。 AOP：面向切面编程，看一下维基百科上的解释： In computing, aspect-oriented programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. AOP是一种编程范式用来增加程序的模块化通过横切关联点的分类（不是人话）。解释一下：传统的业务逻辑是从头到尾一块一块执行的，将整块的逻辑分类出核心和非核心（横切）。 动态代理工具 手动拼接字符串保存为.java文件，其中代理部分通过反射获取各个通知等转换成的字符串，再收到将源代码编译成.class，再通过自定义的classloader加载进来，具体见博客通过代码拼接实现动态代理（拼接字符串，再编译完全模仿了人类手动代理的方式，效率较低，不推荐仅作演示） ASM提供一套API操作java中类似汇编的成分，不过需要使用者能读懂一些java字节码层面的东西，跳过了源代码编译成字节码，效率较高 javassist提供一套api通过易于理解的方式生存字节码 jdk动态代理：基于接口实现，创建一个代理类JDKDynamicProxy实现java.lang.reflect.InvocationHandler接口，https://www.cnblogs.com/zuidongfeng/p/8735241.html cglib动态代理https://blog.csdn.net/yhl_jxy/article/details/80633194 spring-toy在这个框架的AOP实现中，再扫描包的时候将所有的AOP信息(切点，通知)注册: 12345678910111213141516@Overridepublic Map&lt;String, List&lt;AspectAdvisor&gt;&gt; resolve() throws ResolvedException { Map&lt;String, List&lt;AspectAdvisor&gt;&gt; beanAdvisorMapper = new HashMap&lt;&gt;(); for (BeanDefinition beanDefinition : beanDefinitions) { if (beanDefinition.getClazz().getAnnotation(Aspect.class) != null) { List&lt;AspectAdvisor&gt; advisors = resolveAdvisors(beanDefinition); beanAdvisorMapper.put(beanDefinition.getBeanName(), advisors); } } return beanAdvisorMapper;} 然后获得对象的时候生产代理对象将切面“织入”进来，完成对方法的增强: 一下是cjlb产生代理类的过程，其中this本身实现了MethodInterceptor接口 123456789101112131415161718192021222324252627@Overridepublic Object newProxyInstance() throws BeansException { Enhancer enhancer = new Enhancer(); enhancer.setCallback(this); Class targetClass = target.getClass(); Object[] args = null; //处理多实例类 if (targetClass == UnSharedInstance.class) { UnSharedInstance unSharedInstance = (UnSharedInstance) target; targetClass = unSharedInstance.getClazz(); args = unSharedInstance.getArgs(); } enhancer.setSuperclass(targetClass); //执行无参构造方法 if (args == null) { return enhancer.create(); } //获取参数 Class[] argumentTypes = Arrays.stream(args).map(Object::getClass).toArray(Class[]::new); return enhancer.create(argumentTypes, args);} 下面是重写的intercept方法： 12345678910@Overridepublic Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { //获取真实目标实例 Object targetObject = getTargetObject(); Object result = invokeObjectMethod(targetObject, method, args); if (result == null) { result = advisorInvocationHandler.invokeWithAdvice(targetObject, method, args); } return result;} 对方法执行时期debug可以看动intercept方法是如何起作用的，AOP主要通过advisorInvocationHandler.invokeWithAdvice(targetObject, method, args)这个方法实现： 12345678910111213141516171819202122232425262728293031public Object invokeWithAdvice(Object target, Method method, Object[] args) throws Throwable { MethodSignature methodSignature = new MethodSignature(target.getClass(), method); MethodBeforeAdvice[] beforeAdvices = getMethodBeforeAdvices(method, methodSignature); MethodInvocation invocation = new MethodInvocation(target, method, args, beforeAdvices); MethodInterceptor[] aroundAdvices = getAroundAdvices(method, methodSignature); if (aroundAdvices.length &gt; 0) { //执行环绕通知 for (MethodInterceptor aroundAdvice : aroundAdvices) { try { Object returnValue = doAround(aroundAdvice, invocation); doAfterReturning(invocation, returnValue); return returnValue; } catch (Exception e) { doThrows(invocation, e); } } } else { try { Object returnValue = invocation.proceed(); doAfterReturning(invocation, returnValue); return returnValue; } catch (Exception e) { doThrows(invocation, e); } } return null;} 具体是怎么获得通知是在getProxyBean()的时候 123456789101112private AdvisorInvocationHandler getAdviceInvocationHandler() { AdvisorInvocationHandler advisorInvocationHandler = new AdvisorInvocationHandlerImpl(); if (advisors.size() &gt; 0) { advisorInvocationHandler.setAdvisors(advisors); } if (beanFactory != null) { //从BeanFactory获取Aspect通知 AdvisorBeanFactoryImpl advisorBeanFactoryImpl = (AdvisorBeanFactoryImpl) beanFactory; advisorInvocationHandler.setAdvisors(advisorBeanFactoryImpl.getAdvisors()); } return advisorInvocationHandler;} 总结动态代理在增加灵活性方面有巨大作用除了aop在很多框架中存在，spring-toy的ioc部分，以及mybatis 等著名框架，为了“非侵入性”原则，都会使用动态代理。理解动态代理，在很多使用框架的时候就可以了解其内部原理。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"原理","slug":"原理","permalink":"http://papa.lennon.xyz/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"动态代理","slug":"动态代理","permalink":"http://papa.lennon.xyz/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"AOP","slug":"AOP","permalink":"http://papa.lennon.xyz/tags/AOP/"},{"name":"反射","slug":"反射","permalink":"http://papa.lennon.xyz/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"一些网络小知识","slug":"resource/计算机基础/网络","date":"2019-11-24T12:43:39.000Z","updated":"2020-05-15T10:10:49.970Z","comments":true,"path":"/posts/16543121/","link":"","permalink":"http://papa.lennon.xyz/posts/16543121/","excerpt":"","text":"概述近期学习计算机网路，按目前认知先大概地分一下层 首先以网卡来一分为二，上面的都是软件实现的，网卡根据mac地址发送给下一个网卡 讨论一下 网卡以上的，参考《网络是如何连接的》 自认为用模块 这个概念比较合适， 毕竟以我看来，这些都是一个个软件（层），对数据进行封装（整理，添加某些的东西） 这里我们举个例子： 网页本身是 按html规范的字符串，在http这个层面 就加了 啥啥啥 下列这种字符串 后面在内容的里面还是原来的html 1Request URL: https://www.baidu.com/Request Method: GETStatus Code: 200 OKRemote Address: 127.0.0.1:1080Referrer Policy: no-referrer-when-downgrade 后来 tcp 又要 加点东西了就是传说中 的 tcp包 这时候 就会把 http 上封装好的东西看作一个整体，当让也可以发自定义的字符串（字节流） 后来 ip 部分 又要加点东西，，，类似上面的 加完这些东西，把这个数据 丢给网卡，网卡按照上面的mac地址发个和它相连的网卡 90年代，以太网取得垄断地位，以太网成为局域网代名词。数据链路层仅需要MAC层，采用以太网帧格式(Ethernet V2封装：ARPA). 最底层的电路层，具体谈论传输介质啊，方式啥的，比如无线电波，光缆啥的 主要就是数字信号的发送 PS: 数字信号和模拟信号：现阶段，由于传输会失真等原因，数字信号采用只有高低两个点频的二进制数字信号，而模拟信号，主要在耳机孔、vga视频线上，这里拿耳机线举例，直接用电流/电压大小形成的波模拟声波，耳机直接按电流变化改变振动频率即可 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://papa.lennon.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://papa.lennon.xyz/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"简明git github 教程","slug":"resource/工具/简明git_github教程","date":"2019-11-14T02:43:39.000Z","updated":"2020-05-15T10:10:49.970Z","comments":true,"path":"/posts/16105324/","link":"","permalink":"http://papa.lennon.xyz/posts/16105324/","excerpt":"","text":"git git作为程序员必备技能，有人说你不会GitHub连程序员都称不上，但是学生时期毕竟没有团队开的经验，代码量也少，手动复制，压缩包qq发送等传统方式比较主流。但毫无疑问，git是每个开发者都需要会的东西 以我现阶段浅薄的认知给大家简单介绍下git的功能主要分为两点1 版本控制 这里呢版本控制主要体现在两个方面 修改代码提交后，形成一个历史记录，相当于一个永久的ctrl z 撤销 重做功能 可以新建分支，让你的开发，可以分两条路进行，而不是传统的用两个文件夹，更好的实践想法 2 分布式开发 很多小伙伴一开始会好奇git 和 GitHub 的区别，这就要说到git相比于其他版本控制系统的先进之处，可以依靠网络进行分布式开发（很多人在不同电脑上开发同一个项目），这时候就需要一个git服务器，而GitHub就是全球最大的git服务器 单人学习的时候很难接触分布式开发，代码量少，有时候版本控制也没求用，所以学了Git，有时也缺少使用机会（至少我是这样）不过嘛，毕业出去简历上有个github，别人一看你就是内行，加分很多的，而且代码专门放到GitHub上托管，不至于放自己电脑上过几年都找不到，误删了也问题不大教程开始第一步，在本地使用git 熟悉 add commit 创建新仓库在你的代码总文件夹中右键 gitbash here 打开终端git init以创建新的 git 仓库。 接下来git add . （注意点，表示当前目录所有）或者在各种ide编辑器上点加号，可以把改动的文件存到暂存区git commit -m “为这次版本提交的说明” 说明必须填，不加参数 会跳出来一个vim让你填，不填直接退出不能提交 这样一个版本提交就好了，emmmm其实很多时候更新一个版本这种操作都在ide里完成，体验好很多，形成了一个版本，等以后出bug了就可以回滚过来，然后用啥工具找不同，不过目前ide基本上也不支持，命令太麻烦了，也懒得记。。。就跳过吧，真需要去百度查（不过在没有commit之前的撤销在ide里大多是支持，简而言之就是放弃这次更改，还挺有用的） 第二步，使用github，给自己本地的代码来个备份装个逼emmm说实话操作有点多，不过在GitHub上新建一个空仓库跟随指引clone到本地，不过有ssh身份认证啥的，这又是另个一故事了。。。。。请自行百度。。。于是本地就有个空仓库了（相当于已经执行过git init） 两个操作 git pull 同步本地仓库到最新状态 git push origin master 同步远程仓库到最新 .gitignore在项目目录下新建个这个名字的git 并commit进去后。这个文件里的所有文件/文件夹都会被git忽略，当然这个文件本身不会，特别适合，忽略掉一些target（编译生成的可执行文件），.idea(给ide用的） end document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"工具","slug":"工具","permalink":"http://papa.lennon.xyz/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"git","slug":"git","permalink":"http://papa.lennon.xyz/tags/git/"}]},{"title":"Mybatis学习","slug":"resource/java/Mybatis学习","date":"2019-11-07T02:43:39.000Z","updated":"2020-05-15T10:10:49.970Z","comments":true,"path":"/posts/16108532/","link":"","permalink":"http://papa.lennon.xyz/posts/16108532/","excerpt":"","text":"Resources.getResourceAsStream(resource)源码探究:1String resource = \"config.xml\";InputStream inputStream = Resources.getResourceAsStream(resource); mybatis 的 getResourceAsStream(resource) 方法主要通过 1ClassLoader[] getClassLoaders(ClassLoader classLoader) { return new ClassLoader[]{ classLoader, defaultClassLoader, Thread.currentThread().getContextClassLoader(), getClass().getClassLoader(), systemClassLoader};} 获得classloader 然后调用 getResourceAsStream(resource) 方法来获取classpath 下文件的InputStream 生命周期和域相关文档翻译看完基本用法后发现对生命周期这一块理解薄弱在此欲小小翻译一下官方文档中GettingStarted中关于生命周期的说法 Scope and LifecycleIt’s very important to understand the various scopes and lifecycles classes we’ve discussed so far. Using them incorrectly can cause severe concurrency problems. NOTE Object lifecycle and Dependency Injection Frameworks Dependency Injection frameworks can create thread safe, transactional SqlSessions and mappers and inject them directly into your beans so you can just forget about their lifecycle. You may want to have a look at MyBatis-Spring or MyBatis-Guice sub-projects to know more about using MyBatis with DI frameworks. SqlSessionFactoryBuilderThis class can be instantiated, used and thrown away. There is no need to keep it around once you’ve created your SqlSessionFactory. Therefore the best scope for instances of SqlSessionFactoryBuilder is method scope (i.e. a local method variable). You can reuse the SqlSessionFactoryBuilder to build multiple SqlSessionFactory instances, but it’s still best not to keep it around to ensure that all of the XML parsing resources are freed up for more important things. SqlSessionFactoryOnce created, the SqlSessionFactory should exist for the duration of your application execution. There should be little or no reason to ever dispose of it or recreate it. It’s a best practice to not rebuild the SqlSessionFactory multiple times in an application run. Doing so should be considered a “bad smell”. Therefore the best scope of SqlSessionFactory is application scope. This can be achieved a number of ways. The simplest is to use a Singleton pattern or Static Singleton pattern. SqlSessionEach thread should have its own instance of SqlSession. Instances of SqlSession are not to be shared and are not thread safe. Therefore the best scope is request or method scope. Never keep references to a SqlSession instance in a static field or even an instance field of a class. Never keep references to a SqlSession in any sort of managed scope, such as HttpSession of the Servlet framework. If you’re using a web framework of any sort, consider the SqlSession to follow a similar scope to that of an HTTP request. In other words, upon receiving an HTTP request, you can open a SqlSession, then upon returning the response, you can close it. Closing the session is very important. You should always ensure that it’s closed within a finally block. The following is the standard pattern for ensuring that SqlSessions are closed: 1try (SqlSession session = sqlSessionFactory.openSession()) { // do work} Using this pattern consistently throughout your code will ensure that all database resources are properly closed. Mapper InstancesMappers are interfaces that you create to bind to your mapped statements. Instances of the mapper interfaces are acquired from the SqlSession. As such, technically the broadest scope of any mapper instance is the same as the SqlSession from which they were requested. However, the best scope for mapper instances is method scope. That is, they should be requested within the method that they are used, and then be discarded. They do not need to be closed explicitly. While it’s not a problem to keep them around throughout a request, similar to the SqlSession, you might find that managing too many resources at this level will quickly get out of hand. Keep it simple, keep Mappers in the method scope. The following example demonstrates this practice. 1try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); // do work} 域和生命周期理解那些我么将要讨论的多种多样的域和生命周期级别是非常重要的，不正确地使用他们会导致多种多样的并发问题 NOTE Object lifecycle and Dependency Injection Frameworks DI框架可以创建线程安全，事务型的SqlSessions 和 mappers 然后直接将它们注入到beans中，所以你可以不用考虑他们的生命周期．你可能需要看一下MyBatis-Spring和MyBatis-Guice这两个子项目去了解如何配合DI框架使用MyBatis SqlSessionFactoryBuilder这个类可以被实例化，使用和抛出，在你创造了你的SqlSessionFactory后它就没必要继续被保持了，因此SqlSessionFactoryBuilder实例的最佳的域是方法域（比如作为一个本地方法的变量），你依然可以保留SqlSessionFactoryBuilder用以创造多个的SqlSessionFactory实例，但是为了所有和XML语法分析的资源得以释放去做更重要的事，我们最好还是不要保留他． SqlSessionFactory一旦被创建，SqlSessionFactory就应该在你整个应用执行期间存在，我们甚至几乎都没有理由去销毁或者重新创造它，在一个应用运行期间不重新构建SqlSessionFactory多次是一个最佳的惯例，而不这样做通常会被人们认为是个坏事情．因此最好的SqlSessionFactory域应该是application域，有很多种方式可以做到这样，最简单的就是用一个单例模式或者静态单例模式。 SqlSession每个线程应该拥有它自己的SqlSession实例，SqlSession的实例是不被线程共享的，也是线程不安全的，因此对它来说最好的域是方法域和请求域，永远不要将一个SqlSession实例的引用放在一个静态字段甚至一个类的实例字段中，也永远不要放在任何形式的被管理的域比如Servlet framework的HttpSession中，如果你用了任何形式的web框架，考虑把SqlSession放在一个和HTTP 请求差不多的域中，用另一句话来说就是当收到一个HTTP请求，你就可以开一个SqlSession，然后当返回这个相应的时候，你可以关闭它，关闭这个回话是非常重要的，你必须永远确保会话被关闭在一个finally块，下面是确保会话被关闭的标准模式写法： 1try (SqlSession session = sqlSessionFactory.openSession()) { // do work} Mapper InstancesWhile it’s not a problem to keep them around throughout a request, similar to the SqlSession, you might find that managing too many resources at this level will quickly get out of hand. Keep it simple, keep Mappers in the method scope. The following example demonstrates this practice. Mappers是那些你创建来用来绑定你的数据库映射语句的接口，Mapper接口的实例是从SqlSession中获得的。如此来说，从技术上讲Mappers域的最大边界和SqlSession的域（requested域）是一样的。然而，对于mapper的实例来说最好的域是方法域，也就是说它必须在使用它的方法中被请求然后用完后被丢弃，他们不需要被明确地关闭。当然和SqlSession一样保留它们在一整个请求也是没问题的，但是你可能会发现在这种层面上管理太多资源将会马上失控，下面的例子证明了这个实践： 1try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); // do work} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java","slug":"java","permalink":"http://papa.lennon.xyz/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://papa.lennon.xyz/tags/java/"},{"name":"mybatis","slug":"mybatis","permalink":"http://papa.lennon.xyz/tags/mybatis/"},{"name":"Dao","slug":"Dao","permalink":"http://papa.lennon.xyz/tags/Dao/"}]},{"title":"X11 远程图形界面","slug":"resource/工具/远程图形界面","date":"2019-10-07T02:43:39.000Z","updated":"2020-05-15T10:10:49.970Z","comments":true,"path":"/posts/16532102/","link":"","permalink":"http://papa.lennon.xyz/posts/16532102/","excerpt":"","text":"然而现在，直接ubuntu 或 wsl毕竟ubuntu背靠大公司，相比于其他发行版是最接近Windows稳定的（主要原因linux开 IDEA 比Windows快三倍） 方法概述 在hyper-v中建立一个乌班图 分配网卡，在windows 适配器管理里设置共享网络 可以上网以后安装openssh 开启ssh 服务 windows 上 安装 vcXsvr 后台开启x-server服务 地址为 localhost:0.0 打开putty 设置x11 连接 虚拟机后 命令行 idea 便可开启 intellj idea 程序 评价试用了之后 感觉还不错唯一的缺陷是终端实在太丑，终端不好分屏。好在主要使用idea 可以使用里面的终端，vscode也搭好了，不过应该不用~ 也说不上。接下来，装一下 后端主要的数据库 服务器 啥的。 x-client 和 x-serverx-client 主要提供图形界面的数据，也就是model而 x-server 主要把界面画出来 安装了 vcXsvr 相当于用windows的api 把从ssh传过来的数据画成窗口那么，我应该关掉虚拟机linux 里的 自带的 x-sever么转念一想 微软应该已经想到这个了把 详细方法 之后补上界面展示： img img img ubuntu 作为日常开发构建后端终极开发环境参照知乎大神 但是这一切，都可以用VM的方式来解决。我用的是hyper-v。把linux装到hyper-v里面，然后用ssh连接过去，windows本地起一个xserver，所有linux的图形界面都在windows上显示。 要启动VM，只要在powershell里打一句： start-vm ubuntu就行了。要建个快照 powershell里打一句： checkpoint-vm ubuntu，搞定。 基本上，要操作linux的所有东西都可以通过一个powershell命令搞定，不用麻烦的在GUI上点啊点。 但是这一切，都可以用VM的方式来解决。我用的是hyper-v。把linux装到hyper-v里面，然后用ssh连接过去，windows本地起一个xserver，所有linux的图形界面都在windows上显示。 要启动VM，只要在powershell里打一句： start-vm ubuntu就行了。要建个快照 powershell里打一句： checkpoint-vm ubuntu，搞定。 基本上，要操作linux的所有东西都可以通过一个powershell命令搞定，不用麻烦的在GUI上点啊点。 知乎大神的步骤 首先在windows 功能中激活WSL windows subsystem for Linux 和 hyper-V。 注意hyper-v 需要win10 pro版才有。请想办法升级到pro版。 等上述功能安装完成后，下载ubuntu LTS的iso，我用的是16.04LTS，最近18也出了，选择你喜欢用版本，下载下来。 在开始菜单中搜索hyper-v打开hyper-v控制器 在hyper-v中打开虚拟交换机管理器，之前应该只有一个默认连接，按你的需求建立好网络连接，我一般会另外建立一个host only的网络，用于windows host与vm进行通讯。 建好后，新建一个叫ubuntu的VM，设置好网络，内存硬盘等，如果可能的话，尽量给它16G以上的内存。在VM中安装好ubuntu和各种vm-tools，以及sshd，同时配置好host only 的网络，使用staticIP。关掉hyper-v管理器，之后我们不再需要它了。之后所有的操作都可以用powershell进行了。 下载安装Xserver，我用的是vcXsvr，有人反应不够稳定，你可以选择你喜欢的，如cygwin/X等。 启动你的xserver并禁用host control。 按windows+r，输入 bash，进入WSL，第一次运行会安装一点东西。启动完成后用vi修改一下你的 ~/.bashrc文件，加入DISPLAY的设置，如export DISPLAY=localhost:0.0， 试试能不能启动glxgears，并用xhost +禁用access control。 现在可以ssh -X 到你的VM了。 在你的VM ssh中试着输入xterm，这时候你应该能看到一个xterm在你的windows桌面显示出来。这就表示环境配置完成了。 操纵VM，可以直接在hyper-v中操作，但是更方便的方法是用powershell，按win+x a，打开一个powershell, 常用的命令列在下面，基本所有的操作都可以用powershell进行操作。hyper-v文档 hyper-v里的X还是蛮卡的，用X Forwarding之后会流畅很多。你可以试一下下。4月18日 狗东买的8g内存到了，给敏宝的电脑加上，16g 加 不锁频的8550 性能应该可以，上次装完，试验了内存占用太大，这次继续 #4月23日 关于linux 虚拟机网络感觉 很多关于网络的东西不懂 看书先学习一下大概主要学习完了虚拟机上的网络三种按 hyper-v 分 内部 nat 网络地址转化，我设置了共享就可以上网了，是一个相对独立的网络环境 主机能ping虚拟机 虚拟机就好像直接连在互联网上 外部 也就是桥接，装完后相当于电脑局域网上一个机子，需要网桥连接 实际上我还没搞懂 专用 hostonly 只和本机 数据交互 放弃ubuntu 桌面版 安装 ubuntu 服务器版尝试了很很多次，安装了n遍 又仔细看了下知乎下面的评论 具体研究了下虚拟机下的网络谷歌看了很多文章 突然看到百度一篇很有用的样子参考博客 后续：服务器版本 装桌面环境太复杂，c盘空间不够。删了 放弃服务器版 返回桌面版 最终基本成功经过两三天 n 小时的折腾 卡顿程度稍好于虚拟机，窗口拖动较友好可能还是比不了真机，但真机实在不适合笔记本，先用着看，明天开始搭环境 web 开发走起可能适合喜欢用键盘的人 鼠标可能还是不适合 还有输入中文有问题 具体操作参见我另一篇博客一不小心 Ubuntu 重启后又不能联网了，正好我想把xserver关掉关不掉，这回直接安装服务器版本 网络重装完又不行，折腾一两天，这次感觉终于弄懂了 关键步骤 懂的人都懂 hyper-v 新添加个internal 的网卡，在windows 里面共享一下 查看 internal 网卡 ip 192.168.137.1 设置ubuntu IP地址 192.168.137.[2~254] 网关为 192.168.137.1 dns 设置随便找一个靠谱的 代码如下： ifconfig 查看网卡信息 vim /etc/etc/netplan/xxxx.yaml 开始编辑网络文件 注意目前只发现ubuntu用了netplan 其他的请自行谷歌啥怎么配网络 sudo netplan apply 踩的坑 其实桥接和直接用nat都行在这上面废了很大功夫 主机能ping 虚拟机 虚拟机不能ping 主机是因为windows防火墙 虚拟机一直不能联网，一直没有怀疑过dns （配置文件里叫 nameserver 我也没注意到）（老实说一开始我还不知道啥啥相互ping 就以为是 连接问题 虚拟机ping我阿里云服务器可以 突然意识到 原理 关于虚拟机两种网络关系，简单来说，就是创造了个邻居还是儿子 hyper-v 虚拟机比较适合linux 服务器 和windows 虚拟Windows性能几乎无损 插上网线，配好ip等等，应该就可以联网了 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"工具","slug":"工具","permalink":"http://papa.lennon.xyz/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://papa.lennon.xyz/tags/linux/"},{"name":"x11","slug":"x11","permalink":"http://papa.lennon.xyz/tags/x11/"}]},{"title":"操作系统入门","slug":"resource/计算机基础/操作系统入门","date":"2019-10-07T02:43:39.000Z","updated":"2020-05-15T10:10:49.970Z","comments":true,"path":"/posts/161045342/","link":"","permalink":"http://papa.lennon.xyz/posts/161045342/","excerpt":"","text":"操作系统 导言 此文 为 《现代操作系统》 第一章 “引论”的归纳总结，主要 分为两个部分： 硬件和软件 稍加补充: 小概念 我的小感悟（待补充） 计算机硬件处理器 processor 指令集的概念 x86 arm 可以理解为汇编的 指令 比如 取出一个数，加，自增 寄存器 变量和临时结果的通用寄存器 序员可见的专用寄存器 for example 程序counter 保留下一条指令的地址 stack pointer 内存中当前栈的顶部 program status word PSW 包括条件码位 cpu 优先级 模式（用户态，内核态）等等各种控制的 通常 一下子全读取 但只用其中一小部分，在I/O的时候 作用很重要 流水线：取指 -&gt; 解码 -&gt; 执行 前后都在动 多超标量 cpu ： （取指 -&gt; 解码）* n (缓存区) ==&gt; 执行 内核态 用户态 用户态很多操作是禁止的 执行的指令集是全部的一个子集 为了从操作系统中获得服务，（system call）用户程序必须用（TRAP） 指令 切换 多线程 在纳秒间来回切换 类似多个cpu 还有 多核（需要特别操作系统） 储存器 memory cash 主存 random access memory rom 便宜 速度快 引导模块 I/O卡 Electrically Erasable PROM 电可擦除可编程ROM 和 flash memory 非易失性，写的速度比 rom 慢 多次擦写 损耗 cmos 计算机时钟 关机也能正确更新 小电池 用cmos很省电 磁盘I/O 控制器复杂操作 小型计算机 设备本身规范化的接口 STAT 驱动 内核态/用户态 cpu 中断 阻塞 总线计算机的启动 操作系统概念小概念 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://papa.lennon.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://papa.lennon.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"工具","slug":"工具","permalink":"http://papa.lennon.xyz/categories/%E5%B7%A5%E5%85%B7/"},{"name":"js","slug":"js","permalink":"http://papa.lennon.xyz/categories/js/"},{"name":"java","slug":"java","permalink":"http://papa.lennon.xyz/categories/java/"},{"name":"wego","slug":"wego","permalink":"http://papa.lennon.xyz/categories/wego/"},{"name":"原理","slug":"原理","permalink":"http://papa.lennon.xyz/categories/%E5%8E%9F%E7%90%86/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://papa.lennon.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"git","slug":"git","permalink":"http://papa.lennon.xyz/tags/git/"},{"name":"vue","slug":"vue","permalink":"http://papa.lennon.xyz/tags/vue/"},{"name":"npm","slug":"npm","permalink":"http://papa.lennon.xyz/tags/npm/"},{"name":"node","slug":"node","permalink":"http://papa.lennon.xyz/tags/node/"},{"name":"element ui","slug":"element-ui","permalink":"http://papa.lennon.xyz/tags/element-ui/"},{"name":"加密","slug":"加密","permalink":"http://papa.lennon.xyz/tags/%E5%8A%A0%E5%AF%86/"},{"name":"hash","slug":"hash","permalink":"http://papa.lennon.xyz/tags/hash/"},{"name":"vscode","slug":"vscode","permalink":"http://papa.lennon.xyz/tags/vscode/"},{"name":"docker","slug":"docker","permalink":"http://papa.lennon.xyz/tags/docker/"},{"name":"springCloud","slug":"springCloud","permalink":"http://papa.lennon.xyz/tags/springCloud/"},{"name":"java","slug":"java","permalink":"http://papa.lennon.xyz/tags/java/"},{"name":"分布式","slug":"分布式","permalink":"http://papa.lennon.xyz/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"spring","slug":"spring","permalink":"http://papa.lennon.xyz/tags/spring/"},{"name":"语言","slug":"语言","permalink":"http://papa.lennon.xyz/tags/%E8%AF%AD%E8%A8%80/"},{"name":"软件安装","slug":"软件安装","permalink":"http://papa.lennon.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"动态代理","slug":"动态代理","permalink":"http://papa.lennon.xyz/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"AOP","slug":"AOP","permalink":"http://papa.lennon.xyz/tags/AOP/"},{"name":"反射","slug":"反射","permalink":"http://papa.lennon.xyz/tags/%E5%8F%8D%E5%B0%84/"},{"name":"网络","slug":"网络","permalink":"http://papa.lennon.xyz/tags/%E7%BD%91%E7%BB%9C/"},{"name":"mybatis","slug":"mybatis","permalink":"http://papa.lennon.xyz/tags/mybatis/"},{"name":"Dao","slug":"Dao","permalink":"http://papa.lennon.xyz/tags/Dao/"},{"name":"linux","slug":"linux","permalink":"http://papa.lennon.xyz/tags/linux/"},{"name":"x11","slug":"x11","permalink":"http://papa.lennon.xyz/tags/x11/"},{"name":"操作系统","slug":"操作系统","permalink":"http://papa.lennon.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}